
“厚物”扩展板
==============================

简介
==============================
虚怀若谷，厚德载物。厚物——虚谷号第一块多功能扩展板，外扩虚谷号通用I/O管脚，兼容DFRobot Gravity 3-Pin传感器接口，可外接众多传感器及模组。围绕国家“新时代，新课标，新课堂”课改要求，针对学校电子信息课实际教学场景，主打编程教学体验。

虚谷号是中国电子学会创客教育专家委员会针对中国创客教育现状设计的一块符合中国情的开源硬件控制器。满足现有的基础教育需求，兼容市场主流开源硬件，集Arduino，树莓派，micro:bit等优点于一身，兼具高性能与高性价比。虚谷号面向人工智能教育，采用中国芯片，打造中国版开源硬件——虚怀若谷，包容一切！

厚物扩展板，集成一组双路电机驱动，0.96英寸OLED12864显示屏，无源蜂鸣器及一列RGB全彩LED灯，满足现场教学应用及比赛场景设计。支持电机外接供电，满足机器人等应用场景；OLED既可作为Linux调试窗口，又可作为传感器数据显示来用；蜂鸣器及RGB全彩LED灯可贴合实际交通信号指示灯场景，满足课程教学应用。板载五向开关及A/B按键设计，可作程序调试开关使用。

特性
==============================

- 双路电机驱动
- OLED显示
- 一列三个RGB LED
- 蜂鸣器提醒
- 五向开关及A/B调试按钮
- 兼容Gravity传感器

技术规格
==============================

- 兼容主板：虚谷号
- 工作电压：3.3V/5V兼容
- 电机驱动：TB6612FNG
- 驱动电流：1.2A连续电流；2A/3.2A启动电流(连续脉冲/单脉冲)
- 电机外接供电：<12V
- OLED屏幕尺寸：0.96英寸
- OLED屏幕分辨率：128x64
- 无源蜂鸣器
- RGB LED x3
- 五向开关按键（A0口）
- A/B按键调试按键（默认下拉）
- 尺寸：53.5*85.5mm

引脚说明
==============================

.. image:: ../images/08/houwu01.png

.. image:: ../images/08/houwu02.png

使用教程
==============================

本教程会对扩展板基础功能做必要的解释和说明。 

**准备**
硬件：
1 x 虚谷号控制板
1 x 厚物扩展板

软件：
Arduino IDE（虚谷号自带）

将厚物扩展板插到虚谷号上，虚谷号通电（推荐5V@2A USB供电）。



功能清单
==============================
点亮OLED屏幕
------------------------------
厚物扩展板的板载OLED屏幕采用I2C通信方式，地址：0x3C，内部硬件连接到Arduino I2C口：SDA&SCL（A4&A5），又通过电平转换芯片同时连接到虚谷号I2C口（SCL1&SDA1），既可以作为传感器数据显示屏，又可作为系统调试窗口使用。

支持通用U8glib库文件，U8glib作为一个多功能显示库，有许多独特的功能，包括现实图片和打印数据，更多功能，可查看样例U8glib > Examples.

打开文件->示例->U8glib->U8gLogo，如下图所示：

.. image:: ../images/08/houwu03.png

选择 U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE | U8G_I2C_OPT_DEV_0);	// I2C / TWI，取消注释，如下图所示：

.. image:: ../images/08/houwu04.png


源码如下：
------------------------------

/*

  U8gLogo.pde

  Put the U8GLIB logo on the display.

  >>> Before compiling: Please remove comment from the constructor of the
  >>> connected graphics display (see below).

  Universal 8bit Graphics Library, https://github.com/olikraus/u8glib/

  Copyright (c) 2012, olikraus@gmail.com
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this list
    of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice, this
    list of conditions and the following disclaimer in the documentation and/or other
    materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#include "U8glib.h"

U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE | U8G_I2C_OPT_DEV_0);	// I2C / TWI

//#define MINI_LOGO

void drawColorBox(void)
{
  u8g_uint_t w, h;
  u8g_uint_t r, g, b;

  w = u8g.getWidth() / 32;
  h = u8g.getHeight() / 8;
  for ( b = 0; b < 4; b++ )
    for ( g = 0; g < 8; g++ )
      for ( r = 0; r < 8; r++ )
      {
        u8g.setColorIndex((r << 5) |  (g << 2) | b );
        u8g.drawBox(g * w + b * w * 8, r * h, w, h);
      }
}

void drawLogo(uint8_t d)
{
#ifdef MINI_LOGO
  u8g.setFont(u8g_font_gdr17r);
  u8g.drawStr(0 + d, 22 + d, "U");
  u8g.setFont(u8g_font_gdr20n);
  u8g.drawStr90(17 + d, 8 + d, "8");
  u8g.setFont(u8g_font_gdr17r);
  u8g.drawStr(39 + d, 22 + d, "g");

  u8g.drawHLine(2 + d, 25 + d, 34);
  u8g.drawVLine(32 + d, 22 + d, 12);
#else
  u8g.setFont(u8g_font_gdr25r);
  u8g.drawStr(0 + d, 30 + d, "U");
  u8g.setFont(u8g_font_gdr30n);
  u8g.drawStr90(23 + d, 10 + d, "8");
  u8g.setFont(u8g_font_gdr25r);
  u8g.drawStr(53 + d, 30 + d, "g");

  u8g.drawHLine(2 + d, 35 + d, 47);
  u8g.drawVLine(45 + d, 32 + d, 12);
#endif
}

void drawURL(void)
{
#ifndef MINI_LOGO
  u8g.setFont(u8g_font_4x6);
  if ( u8g.getHeight() < 59 )
  {
    u8g.drawStr(53, 9, "code.google.com");
    u8g.drawStr(77, 18, "/p/u8glib");
  }
  else
  {
    u8g.drawStr(1, 54, "code.google.com/p/u8glib");
  }
#endif
}


void draw(void) {
  if ( u8g.getMode() == U8G_MODE_R3G3B2 ) {
    drawColorBox();
  }
  u8g.setColorIndex(1);
  if ( U8G_MODE_GET_BITS_PER_PIXEL(u8g.getMode()) > 1 ) {
    drawLogo(2);
    u8g.setColorIndex(2);
    drawLogo(1);
    u8g.setColorIndex(3);
  }
  drawLogo(0);
  drawURL();

}

void setup(void) {
  // flip screen, if required
  //u8g.setRot180();
}

void loop(void) {

  // picture loop
  u8g.firstPage();
  do {
    draw();
    u8g.setColorIndex(1);
  } while ( u8g.nextPage() );

  // rebuild the picture after some delay
  delay(200);
}


RGB全彩LED灯
------------------------------

厚物扩展板采用WS2812 RGB全彩LED灯珠，内部硬件连接到Arduino D9管脚，可通过Adafruit Neopixel灯带库来驱动

源码如下
------------------------------

#include <Adafruit_NeoPixel.h>
#ifdef __AVR__
  #include <avr/power.h>
#endif

#define PIN 9        //注意修改LED驱动管脚！！！

// Parameter 1 = number of pixels in strip
// Parameter 2 = Arduino pin number (most are valid)
// Parameter 3 = pixel type flags, add together as needed:
//   NEO_KHZ800  800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)
//   NEO_KHZ400  400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers)
//   NEO_GRB     Pixels are wired for GRB bitstream (most NeoPixel products)
//   NEO_RGB     Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)
//   NEO_RGBW    Pixels are wired for RGBW bitstream (NeoPixel RGBW products)
Adafruit_NeoPixel strip = Adafruit_NeoPixel(64, PIN, NEO_GRB + NEO_KHZ800);

// IMPORTANT: To reduce NeoPixel burnout risk, add 1000 uF capacitor across
// pixel power leads, add 300 - 500 Ohm resistor on first pixel's data input
// and minimize distance between Arduino and first pixel.  Avoid connecting
// on a live circuit...if you must, connect GND first.

void setup() {
  // This is for Trinket 5V 16MHz, you can remove these three lines if you are not using a Trinket
  #if defined (__AVR_ATtiny85__)
    if (F_CPU == 16000000) clock_prescale_set(clock_div_1);
  #endif
  // End of trinket special code


  strip.begin();
  strip.show(); // Initialize all pixels to 'off'
}

void loop() {
  // Some example procedures showing how to display to the pixels:
  //colorWipe(strip.Color(255, 0, 0), 50); // Red
 // colorWipe(strip.Color(0, 255, 0), 50); // Green
  //colorWipe(strip.Color(0, 0, 255), 50); // Blue
//colorWipe(strip.Color(0, 0, 0, 255), 50); // White RGBW
  // Send a theater pixel chase in...
 // theaterChase(strip.Color(127, 127, 127), 50); // White
  //theaterChase(strip.Color(127, 0, 0), 50); // Red
  //theaterChase(strip.Color(0, 0, 127), 50); // Blue

  rainbow(20);
  //rainbowCycle(20);
  //theaterChaseRainbow(50);
}

// Fill the dots one after the other with a color
void colorWipe(uint32_t c, uint8_t wait) {
  for(uint16_t i=0; i<strip.numPixels(); i++) {
    strip.setPixelColor(i, c);
    strip.show();
    delay(wait);
  }
}

void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256; j++) {
    for(i=0; i<strip.numPixels(); i++) {
      strip.setPixelColor(i, Wheel((i+j) & 255));
    }
    strip.show();
    delay(wait);
  }
}

// Slightly different, this makes the rainbow equally distributed throughout
void rainbowCycle(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256*5; j++) { // 5 cycles of all colors on wheel
    for(i=0; i< strip.numPixels(); i++) {
      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));
    }
    strip.show();
    delay(wait);
  }
}

//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t wait) {
  for (int j=0; j<10; j++) {  //do 10 cycles of chasing
    for (int q=0; q < 3; q++) {
      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, c);    //turn every third pixel on
      }
      strip.show();

      delay(wait);

      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, 0);        //turn every third pixel off
      }
    }
  }
}

//Theatre-style crawling lights with rainbow effect
void theaterChaseRainbow(uint8_t wait) {
  for (int j=0; j < 256; j++) {     // cycle all 256 colors in the wheel
    for (int q=0; q < 3; q++) {
      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, Wheel( (i+j) % 255));    //turn every third pixel on
      }
      strip.show();

      delay(wait);

      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, 0);        //turn every third pixel off
      }
    }
  }
}

// Input a value 0 to 255 to get a color value.
// The colours are a transition r - g - b - back to r.
uint32_t Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;
  if(WheelPos < 85) {
    return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  }
  if(WheelPos < 170) {
    WheelPos -= 85;
    return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
  WheelPos -= 170;
  return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
}
